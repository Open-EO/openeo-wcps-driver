[

    {
  "id": "stretch_colors",
  "description": "Color stretching",
  "parameters": {
    "data": {
      "description": "EO data to process.",
      "required": true,
      "schema": {
        "type": "object",
        "format": "eodata"
      }
    },
    "min": {
      "description": "Minimum value",
      "required": true,
      "schema": {
        "type": "number"
      }
    },
    "max": {
      "description": "Maximum value",
      "required": true,
      "schema": {
        "type": "number"
      }
    }
  },
  "returns": {
    "description": "Processed EO data.",
    "schema": {
      "type": "object",
      "format": "eodata"
    }
  }
}, 
{
    "id": "load_result",
    "summary": "Load batch job results",
    "description": "Loads batch job results by job id from the local user workspace / data store. The job must have been stored by the authenticated user on the back-end currently connected to.",
    
    "parameters": {
      "url": {
        "description": "An URL to job results.",
        "schema": {
          "type": "string",
          "format": "url",
          "examples": [
            "http://host.com/api/v3/jobs/12345/results"
          ]
        }
      },
      "id": {
        "description": "The id of a batch job with results.",
        "schema": {
          "type": "string",
          "examples": [
            "12345"
          ]
        }
      }
    },
    "returns": {
      "description": "A data cube for further processing.",
      "schema": {
        "type": "object",
        "format": "eodata"
      }
    }
},

    {
        "id": "NDVI",
        "summary": "Normalized Difference Vegetation Index",
        "description": "Computes the Normalized Difference Vegetation Index (NDVI). The NDVI is computed as *(nir - red) / (nir + red)*.\n\nThe `data` parameter expects a raster data cube with two bands that have the common names `red` and `nir` assigned. The process returns a raster data cube with two bands being replaced with a new band that holds the computed values. The newly created band is named `ndvi` by default. This name can be changed with the `name` parameter.\n\nThis process is very similar to the process ``normalized_difference()``, but determines the bands automatically based on the common name (`red`/`nir`) specified in the metadata.",
        
        "parameters": {
                       "data": {
                                "description": "A raster data cube with two bands that have the common names `red` and `nir` assigned.",
                                "required": true,
                                "schema": {
                                           "type": "object",
                                           "format": "raster-cube"
                                          }
                                },
                       "red": {
                                "description": "The name or identifier of band containing the red part of the spectrum",
                                "required": true,
                                "schema": {
                                          "type": "string"
                                          }
                                  },
                       "nir": {
                                "description": "The name or identifier of band containing the near infrared part of the spectrum",
                                "required": true,
                                "schema": {
                                          "type": "string"
                                          }
                                  }
                         },
         "returns": {
                     "description": "A raster data cube with the two bands being replaced with a new band that holds the computed values.",
                     "schema": {
                                "type": "object",
                                "format": "raster-cube"
                               }
                    },                    
         "exceptions": {
                        "RedBandInvalid": {
                                           "description": "The specified red band is not available or contains invalid data."
                                          },
                        "NirBandInvalid": {
                                           "description": "The specified nir band is not available or contains invalid data."
                                          }
                       }
        },
                     
    {
        "id": "min_time",
        "summary": "Calculates minimum values of time series.",
        "description": "Finds the minimum value of a time series for every given pixel location for all bands.",
        
        "parameters": {
                       "data": {
                                   "description": "EO data to process.",
                                   "required": true,
                                   "schema": {
                                              "type": "object",
                                              "format": "eodata"
                                          }
                                }
                         },
         "returns": {
                     "description": "Processed EO data.",
                     "schema": {
                                "type": "object",
                                "format": "eodata"
                               }
                    }
    },
    {
        "id": "max_time",
        "summary": "Calculates maximum values of time series.",
        "description": "Finds the maximum value of a time series for every given pixel location for all bands.",
        
        "parameters": {
                       "data": {
                                   "description": "EO data to process.",
                                   "required": true,
                                   "schema": {
                                              "type": "object",
                                              "format": "eodata"
                                          }
                                }
                         },
         "returns": {
                     "description": "Processed EO data.",
                     "schema": {
                                "type": "object",
                                "format": "eodata"
                               }
                    }
    },
    {
        "id": "filter_temporal",
        "summary": "Filters by Temporal Extent",
        "description": "Creates a subset of data including only the values inside a given data range.",
        
        "parameters": {
                       "data": {
                                   "description": "EO data to process.",
                                   "required": true,
                                   "schema": {
                                              "type": "object",
                                              "format": "eodata"
                                          }
                                },
                       "extent": {
                                  "description": "Left-closed temporal interval, i.e. an array with exactly two elements:\n\n1. The first element is the start of the date and/or time interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the date and/or time interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.\n\nAlso supports open intervals by setting one of the boundaries to `null`, but never both.",
                                  "required": true,
                                  "schema": {
                                             "type": "array",
                                             "format": "temporal-interval",
                                             "examples": [
                                                        "2016-01-01T00:00:00Z",
                                                        "2017-10-01T00:00:00Z"
                                                        ],
                                             "minItems": 2,
                                             "maxItems": 2,
                                             "items": {
                                                    "type":  [ "string", "null" ],
                                                    "format": "date-time"
                                                   }
                                          }
                                }
                         },
         "returns": {
                     "description": "A data cube restricted to the specified temporal extent. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
                     "schema": {
                                "type": "object",
                                "format": "raster-cube"
                               }
                    }
    },
    {
        "id": "filter_bbox",
        "summary": "Spatial filter using a bounding box",
        "description": "Limits the data cube to the specified bounding box.\n\nThe filter retains a pixel in the data cube if the point at the pixel center intersects with the bounding box (as defined in the Simple Features standard by the OGC).",
        
        "parameters": {
                       "data": {
                                "description": "A data cube.",
                                "required": true,
                                "schema": {
                                           "type": "object",
                                           "format": "raster-cube"
                                          }
                                },
                       "extent": {
                                "description": "A bounding box, which may include a vertical axis (see `base` and `height`).\n\nThe coordinate reference system of the extent must be specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition.",
                                "required": true,
                                "schema": {
                                           "type": "object",
                                           "format": "bounding-box",
                                           
                                           "required": [
                                                        "west",
                                                        "south",
                                                        "east",
                                                        "north"
                                                       ],
                                           "properties": {
                                                          "crs": {
                                                                  "description": "Coordinate reference system of the extent specified as EPSG code or PROJ definition. Whenever possible, it is recommended to use EPSG codes instead of PROJ definitions. Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
                                                                  "type": "string",
                                                                  "default": "EPSG:4326"
                                                                 },
                                                          "west": {
                                                                   "description": "West (lower left corner, coordinate axis 1).",
                                                                   "type": "number"
                                                                  },
                                                          "south": {
                                                                    "description": "South (lower left corner, coordinate axis 2).",
                                                                    "type": "number"
                                                                   },
                                                          "east": {
                                                                   "description": "East (upper right corner, coordinate axis 1).",
                                                                   "type": "number"
                                                                  },
                                                          "north": {
                                                                    "description": "North (upper right corner, coordinate axis 2).",
                                                                    "type": "number"
                                                                   },
                                                          "base": {
                                                                   "description": "Base (optional, lower left corner, coordinate axis 3).",
                                                                   "type": "number"
                                                                  },
                                                          "height": {
                                                                     "description": "Height (optional, upper right corner, coordinate axis 3).",
                                                                     "type": "number"
                                                                    }
                                                         }
                                          }
                                 }                   
                         },
         "returns": {
                     "description": "A data cube restricted to the bounding box. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
                     "schema": {
                                "type": "object",
                                "format": "raster-cube"
                               }
                    }
    },
    {
        "id": "load_collection",
        "summary": "Load a collection",
        "description": "Loads a collection from the current back-end by its id and returns it as processable data cube. The data that is added to the data cube can be restricted with the additional `spatial_extent`, `temporal_extent`, `bands` and `properties`.\n\n**Remarks:**\n\n* The bands (and all dimensions that specify nominal dimension values) are expected to be ordered as specified in the metadata if the `bands` parameter is set to `null`.\n* If no additional parameter is specified this would imply that the whole data set is expected to be loaded. Due to the large size of many data sets this is not recommended and may be optimized by back-ends to only load the data that is actually required after evaluating subsequent processes such as filters. This means that the pixel values should be processed only after the data has been limited to the required extents and as a consequence also to a manageable size.",
        
        "parameters": {
                       "id": {
                                "description": "The collection id.",                                
                                "schema": {
                                           "type": "string",
                                           "examples": [ "Sentinel2A-L1C" ]
                                          }
                                },
                       "spatial_extent": {
                                "description": "Limits the data to load from the collection to the specified bounding box or polygons.\n\nThe process puts a pixel into the data cube if the point at the pixel center intersects with the bounding box or any of the polygons (as defined in the Simple Features standard by the OGC).\n\nThe coordinate reference system of the bounding box must be specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition.\n\nThe GeoJSON can be one of the following GeoJSON types:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",                               
                                "schema": {
                                           "type": "object",
                                           "format": "bounding-box"
                                          }
                                },
                       "temporal_extent": {
                                "description": "Limits the data to load from the collection to the specified left-closed temporal interval. Applies to all temporal dimensions if there are multiple of them. The interval has to be specified as an array with exactly two elements:\n\n1. The first element is the start of the date and/or time interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the date and/or time interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.\n\nAlso supports open intervals by setting one of the boundaries to `null`, but never both.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",                                
                                "schema": {
                                           "type": "array",
                                           "format": "temporal-interval"
                                          }
                                },         
                       "bands": {
                                "description": "Only adds the specified bands into the data cube so that bands that don't match the list of band names are not available. Applies to all dimensions of type `bands` if there are multiple of them.\n\nThe order of the specified array defines the order of the bands in the data cube.",
                                "schema": {
                                          "type": "array",
                                          "items": {
                                                     "type": "string",
                                                     "format": "band-name"
                                                    }
                                          }
                                },
                       "properties": {
                                  "description": "Limits the data by metadata properties to include only data in the data cube which all given expressions return `true` for (AND operation).\n\nSpecify key-value-pairs with the keys being the name of the metadata property, which can be retrieved with the openEO Data Discovery for Collections. The values must be expressions to be evaluated against the collection metadata, see the example.\n\n**Note:** Back-ends may not pass the actual value to the expressions, but pass a proprietary index or a placeholder so that they can use the expressions to query against another data source. So debugging on the callback parameter `value` may lead to unexpected results.",
                                  "schema": {
                                            "type": "object"
                                            
                                            }
                                  }                   
                         },
         "returns": {
                     "description": "A data cube for further processing.",
                     "schema": {
                                "type": "object",
                                "format": "raster-cube"
                               }
                    }
    }
    

] 
