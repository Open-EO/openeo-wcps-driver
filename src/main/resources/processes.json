[
	{
    "id": "resample_cube_spatial",
    "summary": "Resample the spatial dimensions to a target data cube",
    "description": "Resamples the spatial dimensions (x,y) from a source data cube to a target data cube and return the results as a new data cube.",
    "categories": [
        "cubes",
        "aggregate & resample"
    ],
    "parameter_order": ["data", "target", "method"],
    "parameters": {
        "data": {
            "description": "A data cube.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "target": {
            "description": "A data cube that describes the spatial target resolution.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "method": {
            "description": "Resampling method. Methods are inspired by GDAL, see [gdalwarp](https://www.gdal.org/gdalwarp.html) for more information.",
            "schema": {
                "type": "string",
                "default": "near",
                "enum": [
                    "near",
                    "bilinear",
                    "cubic",
                    "cubicspline",
                    "lanczos",
                    "average",
                    "mode",
                    "max",
                    "min",
                    "med",
                    "q1",
                    "q3"
                ]
            }
        }
    },
    "returns": {
        "description": "A data cube with potentially lower spatial resolution and potentially lower cardinality, but the same number of dimensions as the original data cube.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    },
    "links": [
        {
            "href": "https://open-eo.github.io/openeo-api/glossary/#aggregation-and-resampling",
            "rel": "about",
            "title": "Resampling explained in the openEO glossary"
        }
    ]
    },
    {
    "id": "if_custom",
    "summary": "If-Then-Else conditional",
    "description": "If the value passed is `true`, returns the value of the `accept` parameter, otherwise returns the value of the `reject` parameter.\n\nThis is basically an if-then-else construct as in other programming languages.",
    "categories": [
        "logic",
        "comparison",
        "masks"
    ],
    "parameters": {
        "value" : {
            "description": "A boolean value.",
            "schema": {
                "type": "boolean",
                "format": "raster-cube"
            }
        },
        "accept": {
            "description": "A value that is returned if the boolean value is `true`.",
            "schema": {
                "type": "number"
            }
        },
        "reject": {
            "description": "A value that is returned if the boolean value is **not** `true`. Defaults to `null`.",
            "schema": {
                "type": "number"
            },
            "required": false
        }
    },
    "returns": {
        "description": "Either the `accept` or `reject` argument depending on the given boolean value.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    }
    },
    {
    "id": "merge_cubes",
    "summary": "Merging two data cubes",
    "description": "The data cubes have to be compatible. A merge is the inverse of a split if there is no overlap. If data overlaps the parameter `overlap_resolver` must be specified to resolve the overlap. It doesn't add dimensions.",
    "categories": [
        "cubes"
    ],
    "parameter_order": ["cube1", "cube2", "overlap_resolver", "binary"],
    "parameters": {
        "cube1": {
            "description": "The first data cube.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "cube2": {
            "description": "The second data cube.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "overlap_resolver": {
            "description": "A reducer that resolves the conflict if the data overlaps. The reducer must be a callable process (or a set of processes as process graph) such as ``mean()`` that accepts by default array as input. The process can also work on two values by setting the parameter `binary` to `true`. The reducer must return a value of the same data type as the input values in the array. `null` (default) can be specified if no overlap resolver is required.",
            "schema": {
                "anyOf": [
                    {
                        "title": "Unary behaviour",
                        "description": "Passes an array to the reducer.",
                        "type": "object",
                        "format": "callback",
                        "parameters": {
                            "data": {
                                "description": "An array with elements of any data type.",
                                "type": "array",
                                "items": {
                                    "description": "Any data type."
                                }
                            }
                        } 
                    },
                    {
                        "title": "Binary behaviour",
                        "description": "Passes two values to the reducer.",
                        "type": "object",
                        "format": "callback",
                        "parameters": {
                            "x": {
                                "description": "The first value. Any data type could be passed."
                            },
                            "y": {
                                "description": "The second value. Any data type could be passed."
                            }
                        } 
                    },
                    {
                        "title": "No overlap resolver",
                        "type": "null"
                    }
                ],
                "default": null
            }
        },
        "binary": {
            "description": "Specifies whether the process should pass two values to the reducer or a list of values (default).\n\nIf the process passes two values, the reducer must be both associative and commutative as the execution may be executed in parallel and therefore the order of execution is arbitrary.\n\nThis parameter is especially useful for UDFs passed as reducers. Back-ends may still optimize and parallelize processes that work on list of values.",
            "schema": {
                "type": "boolean",
                "default": false
            }
        }
    },
    "returns": {
        "description": "The merged data cube.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    },
    "exceptions": {
        "OverlapResolverMissing": {
            "message": "Two data cubes with overlap but without an overlap resolver have been specified."
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
            "title": "Background information on reduction operators (binary reducers) by Wikipedia"
        }
    ]
    },
	{
    "id": "reduce",
    "summary": "Reduce dimensions",
    "description": "Applies a reducer to a data cube dimension by collapsing all the input values along the specified dimension into an output value computed by the reducer.\n\nThe reducer must be a callable process (or a set of processes as process graph) that accepts by default array as input. The process can also work on two values by setting the parameter `binary` to `true`. The reducer must compute a single or multiple return values of the same type as the input values were. Multiple values must be wrapped in an array. An example for a process returning a single value is ``median()``. In this case the specified dimension would be removed. If a callback such as ``extrema()`` returns multiple values, a new dimension with the specified name in `target_dimension` is created (see the description of the parameter for more information).\n\nA special case is that the reducer can be set to `null`, which is the default if no reducer is specified. It acts as a no-operation reducer so that the remaining value is treated like a reduction result and the dimension gets dropped. This only works on dimensions with a single dimension value left (e.g. after filtering for a single band), otherwise the process fails with a `TooManyDimensionValues` error.\n\nNominal values can be reduced too, but need to be mapped. For example date strings to numeric timestamps since 1970 etc.",
    "categories": [
        "cubes",
        "reducer"
    ],
    "parameter_order": ["data", "reducer", "dimension", "target_dimension", "binary"],
    "parameters": {
        "data": {
            "description": "A data cube.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "reducer": {
            "description": "A reducer to be applied on the specified dimension (see the process description for more details).",
            "schema": {
                "anyOf": [
                    {
                        "title": "Unary behaviour",
                        "description": "Passes an array to the reducer.",
                        "type": "object",
                        "format": "callback",
                        "parameters": {
                            "data": {
                                "description": "An array with elements of any data type.",
                                "type": "array",
                                "items": {
                                    "description": "Any data type."
                                }
                            }
                        } 
                    },
                    {
                        "title": "Binary behaviour",
                        "description": "Passes two values to the reducer.",
                        "type": "object",
                        "format": "callback",
                        "parameters": {
                            "x": {
                                "description": "The first value. Any data type could be passed."
                            },
                            "y": {
                                "description": "The second value. Any data type could be passed."
                            }
                        } 
                    },
                    {
                        "title": "No operation behaviour",
                        "description": "Specifying `null` works only on dimensions with a single dimension value left. In this case the remaining value is treated like a reduction result and the dimension gets dropped.",
                        "type": "null"
                    }
                ],
                "default": null
            }
        },
        "dimension": {
            "description": "The dimension over which to reduce. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Remarks:**\n\n* The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.\n* There could be multiple spatial dimensions such as `x`, `y` or `z`.\n* For multi-spectral imagery there is usually a separate dimension of type `bands` for the bands.",
            "schema": {
                "type": "string"
            },
            "required": true
        },
        "target_dimension": {
            "description": "The name of the target dimension. Only required if the reducer returns multiple values, otherwise ignored. By default creates a new dimension with the specified name and the type `other` (see ``add_dimension()``). If a dimension with the specified name exists, the dimension is replaced, but keeps the original type.",
            "schema": {
                "type": ["string", "null"],
                "default": null
            }
        },
        "binary": {
            "description": "Specifies whether the process should pass two values to the reducer or a list of values (default).\n\nIf the process passes two values, the reducer must be both associative and commutative as the execution may be executed in parallel and therefore the order of execution is arbitrary.\n\nThis parameter is especially useful for UDFs passed as reducers. Back-ends may still optimize and parallelize processes that work on list of values.\n\nThis parameter can't be used with the reducer set to `null`. If a reducer is specified but only a single value is available, the reducer doesn't get executed.",
            "schema": {
                "type": "boolean",
                "default": false
            }
        }
    },
    "returns": {
        "description": "A data cube with the newly computed values. The number of dimensions is reduced for callbacks returning a single value or doesn't change if the callback returns multiple values. The resolution and cardinality are the same as for the original data cube.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    },
    "exceptions": {
        "TooManyDimensionValues": {
            "message": "The number of dimension values exceeds one, which requires a reducer."
        },
        "DimensionNotAvailable": {
            "message": "A dimension with the specified name does not exist."
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://en.wikipedia.org/wiki/Reduction_Operator",
            "title": "Background information on reduction operators (binary reducers) by Wikipedia"
        }
    ]
    },    
    {
    "id": "run_udf",
    "summary": "Run an UDF",
    "description": "Runs an UDF in one of the supported runtime environments.\n\nThe process can either:\n\n1. load and run a locally stored UDF from a file in the workspace of the authenticated user. The path to the UDF file must be relative to the root directory of the user's workspace.\n2. fetch and run a remotely stored and published UDF by absolute URI, for example from [openEO Hub](https://hub.openeo.org)).\n3. run the source code specified inline as string.\n\nThe loaded UDF can be executed in several processes such as ``aggregate_temporal()``, ``apply()``, ``apply_dimension()``, ``filter()`` and ``reduce()``. In this case an array is passed instead of a raster data cube. The user must ensure that the data is properly passed as an array so that the UDF can make sense of it.",
    "categories": [
        "import",
        "udf"
    ],
    "parameter_order": ["data", "udf", "runtime", "version", "context"],
    "parameters": {
        "data": {
            "description": "The data to be passed to the UDF as array or raster data cube.",
            "schema": {
                "anyOf": [
                    {
                        "title": "Raster data cube",
                        "type": "object",
                        "format": "raster-cube"
                    },
                    {
                        "title": "Array",
                        "type": "array",
                        "minItems": 1,
                        "items": {
                            "description": "Any data type."
                        }
                    }
                ]
            },
            "required": true
        },
        "udf": {
            "description": "Either source code, an absolute URL or a path to an UDF script.",
            "schema": {
                "anyOf": [
                    {
                        "description": "URI to an UDF",
                        "type": "string",
                        "format": "uri"
                    },
                    {
                        "description": "Source code as string",
                        "type": "string"
                    }
                ]
            },
            "required": true
        },
        "runtime": {
            "description": "An UDF runtime identifier available at the back-end.",
            "schema": {
                "type": "string"
            },
            "required": true
        },
        "version": {
            "description": "An UDF runtime version. If set to `null`, the default runtime version specified for each runtime is used.",
            "schema": {
                "type": [
                    "string",
                    "null"
                ],
                "default": null
            }
        },
        "context": {
            "description": "Additional data such as configuration options that should be passed to the UDF.",
            "schema": {
                "type": "object",
                "default": {}
            }
        }
    },
    "exceptions": {
        "InvalidVersion": {
            "message": "The specified UDF runtime version is not supported."
        }
    },
    "returns": {
        "description": "The data processed by the UDF. Returns a raster data cube if a raster data cube was passed for `data`. If an array was passed for `data`, the returned value is defined by the context and is exactly what the UDF returned.",
        "schema": {
            "anyOf": [
                {
                    "title": "Raster data cube",
                    "type": "object",
                    "format": "raster-cube"
                },
                {
                    "title": "Any",
                    "description": "Any data type."
                }
            ]
        }
    }
    },
    {
    "id": "count",
    "summary": "Count the number of elements",
    "description": "Gives the number of elements in an array that matches a certain criterion / expression.\n\n**Remarks:**\n\n* By default counts the number of valid elements. A valid element is every element for which ``is_valid()`` returns `true`.\n* To count all elements in a list set the `expression` parameter to boolean `true`.",
    "categories": [
        "arrays",
        "reducer"
    ],
    "parameter_order": ["data", "expression"],
    "parameters": {
        "data": {
            "description": "An array with elements of any data type.",
            "schema": {
                "type": "array",
                "items": {
                    "description": "Any data type is allowed."
                }
            },
            "required": true
        },
        "expression": {
            "description": "An expression that is evaluated against each element in the array. An element is counted only if the expression returns `true`. Defaults to count valid elements in a list (see ``is_valid()``). Setting this parameter to boolean `true` counts all elements in the list.",
            "schema": {
                "anyOf": [
                    {
                        "description": "An expression that is evaluated against each element in the array.",
                        "type": "object",
                        "format": "callback",
                        "parameters": {
                            "x": {
                                "description": "A single value from the array. Any data type could be passed."
                            }
                        }
                    },
                    {
                        "description": "Boolean `true` counts all elements in the list.",
                        "type": "boolean",
                        "const": true
                    },
                    {
                        "description": "`null` counts valid elements in the list.",
                        "type": "null"
                    }
                ],
                "default": null
            }
        }
    },
    "returns": {
        "description": "The counted number of elements.",
        "schema": {
            "type": "number"
        }
    }
    },
    {
    "id": "absolute",
    "summary": "Absolute value",
    "description": "Computes the absolute value of a real number `x`, which is the \"unsigned\" portion of x and often denoted as *|x|*.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math"
    ],
    "parameters": {
        "x": {
            "description": "A number.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed absolute value.",
        "schema": {
            "type": [
                "number",
                "null"
            ],
            "minimum": 0
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/AbsoluteValue.html",
            "title": "Absolute value explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "and",
    "summary": "Are all of the values true?",
    "description": "Checks if **all** of the values are true. Evaluates each expression from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `true` if all other values are true and otherwise returns `false`.\nSetting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null  | false | true\n----- || ----- | ----- | -----\nnull  || null  | false | null\nfalse || false | false | false\ntrue  || null  | false | true\n```",
    "categories": [
        "logic",
        "reducer"
    ],
    "parameter_order": ["expressions", "ignore_nodata"],
    "parameters": {
        "expressions": {
            "description": "A set of boolean values.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "boolean",
                        "null"
                    ]
                }
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "Boolean result of the logical expressions.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    }
    },
    {
    "id": "xor",
    "summary": "Is exactly one value true?",
    "description": "Checks if **exactly one** of the values is true. Evaluates each expression from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `true` if exactly one of the other values is true and otherwise returns `false`.\nSetting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null | false | true\n----- || ---- | ----- | -----\nnull  || null | null  | null\nfalse || null | false | true\ntrue  || null | true  | false\n```",
    "categories": [
        "logic",
        "reducer"
    ],
    "parameter_order": ["expressions", "ignore_nodata"],
    "parameters": {
        "expressions": {
            "description": "A set of boolean values.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "boolean",
                        "null"
                    ]
                }
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "Boolean result of the logical expressions.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    }
    },
    {
    "id": "or",
    "summary": "Is at least one value true?",
    "description": "Checks if **at least one** of the values is true. Evaluates each expression from the first to the last element and stops once the outcome is unambiguous.\n\nIf only one value is given the process evaluates to the given value. If no value is given (i.e. the array is empty) the process returns `null`.\n\nBy default all no-data values are ignored so that the process returns `true` if at least one of the other values is true and otherwise returns `false`.\nSetting the `ignore_nodata` flag to `false` considers no-data values so that `null` is a valid logical object. If a component is `null`, the result will be `null` if the outcome is ambiguous. See the following truth table:\n\n```\n      || null | false | true\n----- || ---- | ----- | ----\nnull  || null | null  | true\nfalse || null | false | true\ntrue  || true | true  | true\n```",
    "categories": [
        "logic",
        "reducer"
    ],
    "parameter_order": ["expressions", "ignore_nodata"],
    "parameters": {
        "expressions": {
            "description": "A set of boolean values.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "boolean",
                        "null"
                    ]
                }
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "Indicates whether no-data values are ignored or not and ignores them by default.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "Boolean result of the logical expressions.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    }
    },
    {
    "id": "not",
    "summary": "Inverting a boolean",
    "description": "Inverts a single boolean so that `true` gets `false` and `false` gets `true`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "logic"
    ],
    "parameters": {
        "expression": {
            "description": "Boolean value to invert.",
            "schema": {
                "type": [
                    "boolean",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "Inverted boolean value.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    }
    },
    {
    "id": "log",
    "summary": "Logarithm to a base",
    "description": "Logarithm to the base `base` of the number `x` is defined to be the inverse function of taking b to the power of x.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) so that for example `log(0, 2)` should result in ±infinity if the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
        "math > exponential & logarithmic"
    ],
    "parameter_order": ["x", "base"],
    "parameters": {
        "x": {
            "description": "A number to compute the logarithm for.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        },
        "base": {
            "description": "The numerical base.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed logarithm.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Logarithm.html",
            "title": "Logarithm explained by Wolfram MathWorld"
        },
        {
            "rel": "about",
            "href": "https://ieeexplore.ieee.org/document/4610935",
            "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
        }
    ]
    },
    {
    "id": "ln",
    "summary": "Natural logarithm",
    "description": "The natural logarithm is the logarithm to the base *e* of the number `x`. This process is an alias for the *log* process with the base set to *e*: `log(x, e())`. The natural logarithm is the inverse function of taking *e* to the power x.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) so that for example `ln(0)` should result in ±infinity if the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > exponential & logarithmic"
    ],
    "parameters": {
        "x": {
            "description": "A number to compute the natural logarithm for.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed natural logarithm.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/NaturalLogarithm.html",
            "title": "Natural logarithm explained by Wolfram MathWorld"
        },
        {
            "rel": "about",
            "href": "https://ieeexplore.ieee.org/document/4610935",
            "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
        }
    ]
    },
    {
    "id": "sqrt",
    "summary": "Square root",
    "description": "Computes the square root of a real number `x`. This process is an alias for `x` to the power of *0.5*: `power(x, 0.5)`.\n\nA square root of x is a number a such that *a^2^ = x*. Therefore, the square root is the inverse function of a to the power of 2, but only for *a >= 0*.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math",
        "math > exponential & logarithmic"
    ],
    "parameters": {
        "x": {
            "description": "A number.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed square root.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/SquareRoot.html",
            "title": "Square root explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "power",
    "summary": "Exponentiation",
    "description": "Computes the exponentiation for the base `base` raised to the power of `p`.\n\nThe no-data value `null` is passed through and therefore gets propagated if any of the arguments is `null`.",
    "categories": [
        "math",
        "math > exponential & logarithmic"
    ],
    "parameter_order": ["base", "p"],
    "parameters": {
        "base": {
            "description": "The numerical base.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        },
        "p": {
            "description": "The numerical exponent.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed value for `base` raised to the power of `p`.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Power.html",
            "title": "Power explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "exp",
    "summary": "Exponentiation to the base e",
    "description": "Exponential function to the base *e* raised to the power of `p`. This process is an alias for *e^p^* / `power(e(), p)`.\n\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > exponential & logarithmic"
    ],
    "parameters": {
        "p": {
            "description": "The numerical exponent.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed value for *e* raised to the power of `p`.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/ExponentialFunction.html",
            "title": "Exponential function explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "pi",
    "summary": "Pi (\u03c0)",
    "description": "The real number Pi (\u03c0) is a mathematical constant that is the ratio of the circumference of a circle to its diameter. The numerical value is approximately *3.14159*.",
    "categories": [
        "math > constants",
        "math > trigonometric"
    ],
    "parameters": {},
    "returns": {
        "description": "The numerical value of Pi.",
        "schema": {
            "type": "number"
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Pi.html",
            "title": "Mathematical constant Pi explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "e",
    "summary": "Euler's number (e)",
    "description": "The real number *e* is a mathematical constant that is the base of the natural logarithm such that *ln(e) = 1*. The numerical value is approximately *2.71828*.",
    "categories": [
        "math > constants",
        "math > exponential & logarithmic"
    ],
    "parameters": {},
    "returns": {
        "description": "The numerical value of Euler's number.",
        "schema": {
            "type": "number"
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/e.html",
            "title": "Mathematical constant e explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "gte",
    "summary": "Greater than or equal to comparison",
    "description": "Compares whether `x` is greater than or equal to `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
        "comparison"
    ],
    "parameter_order": ["x", "y"],
    "parameters": {
        "x": {
            "description": "First operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        },
        "y": {
            "description": "Second operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "`true` if `x` is greater than or equal to `y` or `null` if any of the operands is `null`, otherwise `false`.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
            "title": "Information about the supported temporal formats."
        }
    ]
    },
    {
    "id": "gt",
    "summary": "Greater than comparison",
    "description": "Compares whether `x` is strictly greater than `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
        "comparison"
    ],
    "parameter_order": ["x", "y"],
    "parameters": {
        "x": {
            "description": "First operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        },
        "y": {
            "description": "Second operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "`true` if `x` is strictly greater than `y` or `null` if any of the operands is `null`, otherwise `false`.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
            "title": "Information about the supported temporal formats."
        }
    ]
    },
    {
    "id": "eq",
    "summary": "Equal to comparison",
    "description": "Compares whether `x` is strictly equal to `y`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*. Nevertheless, an integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`.\n* If any of the operands is `null`, the return value is `null`.\n* Strings are expected to be encoded in UTF-8 by default.\n* Temporal strings MUST be compared differently than other strings and MUST NOT be compared based on their string representation due to different possible representations. For example, the UTC time zone representation `Z` has the same meaning as `+00:00`.",
    "categories": [
        "texts",
        "comparison"
    ],
    "parameter_order": ["x", "y", "delta", "case_sensitive"],
    "parameters": {
        "x": {
            "description": "First operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "boolean"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        },
        "y": {
            "description": "Second operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "boolean"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        },
        "delta": {
            "description": "Only applicable for comparing two numbers. If this optional parameter is set to a positive non-zero number the equality of two numbers is checked against a delta value. This is especially useful to circumvent problems with floating point inaccuracy in machine-based computation.\n\nThis option is basically an alias for the following computation: `lte(abs(minus([x, y]), delta)`",
            "schema": {
                "type": ["number", "null"],
                "default": null
            }
        },
        "case_sensitive": {
            "description": "Only applicable for comparing two strings. Case sensitive comparison can be disabled by setting this parameter to `false`.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "Returns `true` if `x` is equal to `y`, `null` if any of the operands is `null`, otherwise `false`.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
            "title": "Information about the supported temporal formats."
        }
    ]
    },
    {
    "id": "lt",
    "summary": "Less than comparison",
    "description": "Compares whether `x` is strictly less than `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
        "comparison"
    ],
    "parameter_order": ["x", "y"],
    "parameters": {
        "x": {
            "description": "First operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        },
        "y": {
            "description": "Second operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "`true` if `x` is strictly less than `y`, `null` if any of the operands is `null`, otherwise `false`.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
            "title": "Information about the supported temporal formats."
        }
    ]
    },
    {
    "id": "lte",
    "summary": "Less than or equal to comparison",
    "description": "Compares whether `x` is less than or equal to `y`.\n\n**Remarks:**\n\n* If any of the operands is `null`, the return value is `null`.\n* Temporal strings can *not* be compared based on their string representation due to the time zone / time-offset representations.\n* Comparing strings is currently not supported, but is planned to be added in the future.",
    "categories": [
        "comparison"
    ],
    "parameter_order": ["x", "y"],
    "parameters": {
        "x": {
            "description": "First operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        },
        "y": {
            "description": "Second operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "`true` if `x` is less than or equal to `y`, `null` if any of the operands is `null`, otherwise `false`.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
            "title": "Information about the supported temporal formats."
        }
    ]
    },
    {
    "id": "neq",
    "summary": "Not equal to comparison",
    "description": "Compares whether `x` is *not* strictly equal to `y`. This process is an alias for: `not(eq(val1, val2))`.\n\n**Remarks:**\n\n* Data types MUST be checked strictly, for example a string with the content *1* is not equal to the number *1*. Nevertheless, an integer *1* is equal to a floating point number *1.0* as `integer` is a sub-type of `number`.\n* If any of the operands is `null`, the return value is `null`.\n* Strings are expected to be encoded in UTF-8 by default.\n* Temporal strings MUST be compared differently than other strings and MUST NOT be compared based on their string representation due to different possible representations. For example, the UTC time zone representation `Z` has the same meaning as `+00:00`.",
    "categories": [
        "texts",
        "comparison"
    ],
    "parameter_order": ["x", "y", "delta", "case_sensitive"],
    "parameters": {
        "x": {
            "description": "First operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "boolean"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        },
        "y": {
            "description": "Second operand.",
            "schema": {
                "anyOf": [
                    {
                        "type": "number"
                    },
                    {
                        "type": "boolean"
                    },
                    {
                        "type": "null"
                    },
                    {
                        "type": "string"
                    },
                    {
                        "type": "string",
                        "format": "date-time"
                    },
                    {
                        "type": "string",
                        "format": "date"
                    },
                    {
                        "type": "string",
                        "format": "time"
                    }
                ]
            },
            "required": true
        },
        "delta": {
            "description": "Only applicable for comparing two numbers. If this optional parameter is set to a positive non-zero number the non-equality of two numbers is checked against a delta value. This is especially useful to circumvent problems with floating point inaccuracy in machine-based computation.\n\nThis option is basically an alias for the following computation: `gt(abs(minus([x, y]), delta)`",
            "schema": {
                "type": ["number", "null"],
                "default": null
            }
        },
        "case_sensitive": {
            "description": "Only applicable for comparing two strings. Case sensitive comparison can be disabled by setting this parameter to `false`.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "Returns `true` if `x` is *not* equal to `y`, `null` if any of the operands is `null`, otherwise `false`.",
        "schema": {
            "type": [
                "boolean",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
            "title": "Information about the supported temporal formats."
        }
    ]
    },
    {
    "id": "sin",
    "summary": "Sine",
    "description": "Computes the sine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > trigonometric"
    ],
    "parameters": {
        "x": {
            "description": "An angle in radians.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed sine of `x`.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Sine.html",
            "title": "Sine explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "cos",
    "summary": "Cosine",
    "description": "Computes the cosine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > trigonometric"
    ],
    "parameters": {
        "x": {
            "description": "An angle in radians.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed cosine of `x`.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Cosine.html",
            "title": "Cosine explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "tan",
    "summary": "Tangent",
    "description": "Computes the tangent of `x`. The tangent is defined to be the sine of x divided by the cosine of x.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > trigonometric"
    ],
    "parameters": {
        "x": {
            "description": "An angle in radians.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed tangent of `x`.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Tangent.html",
            "title": "Tangent explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "sinh",
    "summary": "Hyperbolic sine",
    "description": "Computes the hyperbolic sine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > trigonometric"
    ],
    "parameters": {
        "x": {
            "description": "An angle in radians.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed hyperbolic sine of `x`.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/HyperbolicSine.html",
            "title": "Hyperbolic sine explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "cosh",
    "summary": "Hyperbolic cosine",
    "description": "Computes the hyperbolic cosine of `x`.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > trigonometric"
    ],
    "parameters": {
        "x": {
            "description": "An angle in radians.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed hyperbolic cosine of `x`.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/HyperbolicCosine.html",
            "title": "Hyperbolic cosine explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "tanh",
    "summary": "Hyperbolic tangent",
    "description": "Computes the hyperbolic tangent of `x`. The tangent is defined to be the hyperbolic sine of x divided by the hyperbolic cosine of x.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > trigonometric"
    ],
    "parameters": {
        "x": {
            "description": "An angle in radians.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed hyperbolic tangent of `x`.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/HyperbolicTangent.html",
            "title": "Hyperbolic tangent explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "arcsin",
    "summary": "Inverse sine",
    "description": "Computes the arc sine of `x`. The arc sine is the inverse function of the sine so that *arcsin(sin(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > trigonometric"
    ],
    "parameters": {
        "x": {
            "description": "A number.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed angle in radians.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/InverseSine.html",
            "title": "Inverse sine explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "arccos",
    "summary": "Inverse cosine",
    "description": "Computes the arc cosine of `x`. The arc cosine is the inverse function of the cosine so that *arccos(cos(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > trigonometric"
    ],
    "parameters": {
        "x": {
            "description": "A number.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed angle in radians.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/InverseCosine.html",
            "title": "Inverse cosine explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "arctan",
    "summary": "Inverse tangent",
    "description": "Computes the arc tangent of `x`. The arc tangent is the inverse function of the tangent so that *arctan(tan(x)) = x*.\n\nWorks on radians only.\nThe no-data value `null` is passed through and therefore gets propagated.",
    "categories": [
        "math > trigonometric"
    ],
    "parameters": {
        "x": {
            "description": "A number.",
            "schema": {
                "type": [
                    "number",
                    "null"
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "The computed angle in radians.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/InverseTangent.html",
            "title": "Inverse tangent explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "array_element",
    "summary": "Get an element from an array",
    "description": "Returns the element at the specified index from the array.",
    "categories": [
        "arrays"
    ],
    "parameter_order": ["data", "index", "return_nodata"],
    "parameters": {
        "data": {
            "description": "An array.",
            "schema": {
                "type": "array",
                "items": {
                    "description": "Any data type is allowed."
                }
            },
            "required": true
        },
        "index": {
            "description": "The zero-based index of the element to retrieve.",
            "schema": {
                 "type": "integer"
            },
            "required": true
        },
        "return_nodata": {
            "description": "By default this process throws an `IndexOutOfBounds` exception if the index is invalid. If you want to return `null` instead, set this flag to `true`.",
            "schema": {
                 "type": "boolean",
                 "default": false
            }
        }
    },
    "returns": {
        "description": "The value of the requested element.",
        "schema": {
            "description": "Any data type is allowed."
        }
    },
    "exceptions": {
        "IndexOutOfBounds": {
            "message": "The array has no element with the specified index."
        }
    }
    },
    {
    "id": "product",
    "summary": "Multiplication of a sequence of numbers",
    "description": "This process is an exact alias for the `multiply` process. See ``multiply()`` for more information.",
    "categories": [
        "math",
        "reducer"
    ],
    "parameter_order": ["data", "ignore_nodata"],
    "parameters": {
        "data": {
            "description": "See ``multiply()`` for more information.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "number",
                        "null"
                    ]
                }
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "See ``multiply()`` for more information.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "See ``multiply()`` for more information.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "exceptions": {
        "MultiplicandMissing": {
            "message": "Multiplication requires at least two numbers."
        }
    }
    },
    {
    "id": "sum",
    "summary": "Addition of a sequence of numbers",
    "description": "Sums up all elements in a sequential array of numbers and returns the computed sum.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) whenever the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
        "math",
        "reducer"
    ],
    "parameter_order": ["data", "ignore_nodata"],
    "parameters": {
        "data": {
            "description": "An array of numbers with at least two elements.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "number",
                        "null"
                    ]
                },
                "minItems": 2
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "The computed sum of the sequence of numbers.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "exceptions": {
        "SummandMissing": {
            "message": "Addition requires at least two numbers."
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Sum.html",
            "title": "Sum explained by Wolfram MathWorld"
        },
        {
            "rel": "about",
            "href": "https://ieeexplore.ieee.org/document/4610935",
            "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
        }
    ]
    },
    {
    "id": "subtract",
    "summary": "Subtraction of a sequence of numbers",
    "description": "Takes the first element of a sequential array of numbers and subtracts all other elements from it.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) whenever the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
        "math",
        "reducer"
    ],
    "parameter_order": ["data", "ignore_nodata"],
    "parameters": {
        "data": {
            "description": "An array of numbers with at least two elements.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "number",
                        "null"
                    ]
                },
                "minItems": 2
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "The computed result of the sequence of numbers.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "exceptions": {
        "SubtrahendMissing": {
            "message": "Subtraction requires at least two numbers (a minuend and one or more subtrahends)."
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Subtraction.html",
            "title": "Subtraction explained by Wolfram MathWorld"
        },
        {
            "rel": "about",
            "href": "https://ieeexplore.ieee.org/document/4610935",
            "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
        }
    ]
    },
    {
    "id": "divide",
    "summary": "Division of a sequence of numbers",
    "description": "Divides the first element in a sequential array of numbers by all other elements.\n\nThe computations should follow [IEEE Standard 754](https://ieeexplore.ieee.org/document/4610935) so that for example a division by zero should result in ±infinity if the processing environment supports it. Otherwise an exception must the thrown for incomputable results.\n\nBy default no-data values are ignored. Setting `ignore_nodata` to `false` considers no-data values so that `null` is returned if any element is such a value.",
    "categories": [
        "math",
        "reducer"
    ],
    "parameter_order": ["data", "ignore_nodata"],
    "parameters": {
        "data": {
            "description": "An array of numbers with at least two elements.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "number",
                        "null"
                    ]
                },
                "minItems": 2
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "The computed result of the sequence of numbers.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "exceptions": {
        "DivisorMissing": {
            "message": "Division requires at least two numbers (a dividend and one or more divisors)."
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Division.html",
            "title": "Division explained by Wolfram MathWorld"
        },
        {
            "rel": "about",
            "href": "https://ieeexplore.ieee.org/document/4610935",
            "title": "IEEE Standard 754-2008 for Floating-Point Arithmetic"
        }
    ]
    },
    {
    "id": "mean",
    "summary": "Arithmetic mean (average)",
    "description": "The arithmetic mean of an array of numbers is the quantity commonly called the average. It is defined as the sum of all elements divided by the number of elements.",
    "categories": [
        "math",
        "reducer"
    ],
    "parameter_order": ["data", "ignore_nodata"],
    "parameters": {
        "data": {
            "description": "An array of numbers. An empty array resolves always with `null`.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "number",
                        "null"
                    ]
                }
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "The computed arithmetic mean.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },    
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/ArithmeticMean.html",
            "title": "Arithmetic mean explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "max",
    "summary": "Maximum value",
    "description": "Computes the largest value of an array of numbers, which is is equal to the first element of a sorted (i.e., ordered) version the array.",
    "categories": [
        "math",
        "reducer"
    ],
    "parameter_order": ["data", "ignore_nodata"],
    "parameters": {
        "data": {
            "description": "An array of numbers. An empty array resolves always with `null`.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "number",
                        "null"
                    ]
                }
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "The maximum value.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },    
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Maximum.html",
            "title": "Maximum explained by Wolfram MathWorld"
        }
    ]
    },
    {
    "id": "min",
    "summary": "Minimum value",
    "description": "Computes the smallest value of an array of numbers, which is is equal to the last element of a sorted (i.e., ordered) version the array.",
    "categories": [
        "math",
        "reducer"
    ],
    "parameter_order": ["data", "ignore_nodata"],
    "parameters": {
        "data": {
            "description": "An array of numbers. An empty array resolves always with `null`.",
            "schema": {
                "type": "array",
                "items": {
                    "type": [
                        "number",
                        "null"
                    ]
                }
            },
            "required": true
        },
        "ignore_nodata": {
            "description": "Indicates whether no-data values are ignored or not. Ignores them by default. Setting this flag to `false` considers no-data values so that `null` is returned if any value is such a value.",
            "schema": {
                "type": "boolean",
                "default": true
            }
        }
    },
    "returns": {
        "description": "The minimum value.",
        "schema": {
            "type": [
                "number",
                "null"
            ]
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "http://mathworld.wolfram.com/Minimum.html",
            "title": "Minimum explained by Wolfram MathWorld"
        }
    ]
    },
    {
		"id": "apply",
		"summary": "Applies a unary process to each pixel",
		"description": "Applies a **unary** process which takes a single value such as `abs` or `sqrt` to each pixel value in the data cube (i.e. a local operation). In contrast, the process ``apply_dimension()`` applies an n-ary process to a particular dimension.",
		"categories": [
			"cubes"
		],
		"parameter_order": ["data",	"process"],
		"parameters": {
			"data": {
				"description": "A data cube.",
				"schema": {
					"type": "object",
					"format": "raster-cube"
				},
				"required": true
			},
			"process": {
				"description": "A process (callback) to be applied on each value. The specified process must be unary meaning that it must work on a single value.",
				"schema": {
					"type": "object",
					"format": "callback",
					"parameters": {
						"x": {
							"description": "A value of any type could be passed."
						}
					}
				},
				"required": true
			}
		},
		"returns": {
			"description": "A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		}
	},
	{
		"id": "linear_scale_range",
		"summary": "Linear transformation between two ranges",
		"description": "Performs a linear transformation between the input and output range.\n\nThe underlying formula is: `((x - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin`.\n\nPotential use case include\n\n* scaling values to the 8-bit range (0 - 255) often used for numeric representation of values in one of the channels of the [RGB colour model](https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations) or\n* calculating percentages (0 - 100).\n\nThe no-data value `null` is passed through and therefore gets propagated.",
		"categories": [
			"math"
		],
		"parameter_order": [
			"x",
			"inputMin",
			"inputMax",
			"outputMin",
			"outputMax"
		],
		"parameters": {
			"x": {
				"description": "A number to transform.",
				"schema": {
					"type": [
						"number",
						"null"
					]
				},
				"required": true
			},
			"inputMin": {
				"description": "Minimum value the input can obtain.",
				"schema": {
					"type": "number"
				},
				"required": true
			},
			"inputMax": {
				"description": "Maximum value the input can obtain.",
				"schema": {
					"type": "number"
				},
				"required": true
			},
			"outputMin": {
				"description": "Minimum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 0
				}
			},
			"outputMax": {
				"description": "Maximum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 1
				}
			}
		},
		"returns": {
			"description": "The transformed number.",
			"schema": {
				"type": [
					"number",
					"null"
				]
			}
		}
	},
	{
		"id": "linear_scale_cube",
		"summary": "Linear transformation between two ranges",
		"description": "Performs a linear transformation between the input and output range.\n\nThe underlying formula is: `((x - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin`.\n\nPotential use case include\n\n* scaling values to the 8-bit range (0 - 255) often used for numeric representation of values in one of the channels of the [RGB colour model](https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations) or\n* calculating percentages (0 - 100).\n\nThe no-data value `null` is passed through and therefore gets propagated.",
		"categories": [
			"math"
		],
		"parameter_order": [
			"data",
			"inputMin",
			"inputMax",
			"outputMin",
			"outputMax"
		],
		"parameters": {
			"data": {
                 "description": "A data cube with bands.",
                 "schema": {
                        "type": "object",
                        "format": "raster-cube"
                 },
                 "required": true
            },
			"inputMin": {
				"description": "Minimum value the input can obtain.",
				"schema": {
					"type": "number"
				},
				"required": true
			},
			"inputMax": {
				"description": "Maximum value the input can obtain.",
				"schema": {
					"type": "number"
				},
				"required": true
			},
			"outputMin": {
				"description": "Minimum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 0
				}
			},
			"outputMax": {
				"description": "Maximum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 1
				}
			}
		},
		"returns": {
			"description": "A raster data cube with every value in the cube scaled according to the min and max parameters.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		}
	},
	{
		"id": "linear_stretch_cube",
		"summary": "Linear Stretch transformation between two ranges",
		"description": "Performs a linear transformation between the input and output range.\n\nThe underlying formula is: `((x - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin`.\n\nPotential use case include\n\n* scaling values to the 8-bit range (0 - 255) often used for numeric representation of values in one of the channels of the [RGB colour model](https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations) or\n* calculating percentages (0 - 100).\n\nThe no-data value `null` is passed through and therefore gets propagated.",
		"categories": [
			"math"
		],
		"parameter_order": [
			"data",			
			"min",
			"max"
		],
		"parameters": {
			"data": {
                 "description": "A data cube with bands.",
                 "schema": {
                        "type": "object",
                        "format": "raster-cube"
                 },
                 "required": true
            },
			"min": {
				"description": "Minimum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 0
				}
			},
			"max": {
				"description": "Maximum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 1
				}
			}
		},
		"returns": {
			"description": "A raster data cube with every value in the cube scaled according to the min and max parameters.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		}
	},
	{
		"id": "save_result",
		"summary": "Save processed data to storage",
		"description": "Saves processed data to the local user workspace / data store of the authenticated user. This process aims to be compatible to GDAL/OGR formats and options. STAC-compatible metadata should be stored with the processed data.\n\nCalling this process may be rejected by back-ends in the context of secondary web services.",
		"categories": [
			"cubes",
			"export"
		],
		"parameter_order": [
			"data",
			"format",
			"options"
		],
		"parameters": {
			"data": {
				"description": "The data to save.",
				"schema": {
					"anyOf": [
						{
							"type": "object",
							"format": "raster-cube"
						},
						{
							"type": "object",
							"format": "vector-cube"
						}
					]
				},
				"required": true
			},
			"format": {
				"description": "The file format to save to. It must be one of the values that the server reports as supported output formats, which usually correspond to the short GDAL/OGR codes. This parameter is *case insensitive*.",
				"schema": {
					"type": "string",
					"format": "output-format"
				},
				"required": true
			},
			"options": {
				"description": "The file format options to be used to create the file(s). Must correspond to the options that the server reports as supported options for the chosen `format`. The option names and valid values usually correspond to the GDAL/OGR format options.",
				"schema": {
					"type": "object",
					"format": "output-format-options",
					"default": {
						
					}
				}
			}
		},
		"returns": {
			"description": "`false` if saving failed, `true` otherwise.",
			"schema": {
				"type": "boolean"
			}
		},
		"links": [
			{
				"rel": "about",
				"href": "https://www.gdal.org/formats_list.html",
				"title": "GDAL Raster Formats"
			},
			{
				"rel": "about",
				"href": "https://www.gdal.org/ogr_formats.html",
				"title": "OGR Vector Formats"
			}
		]
	},
	{
    "id": "filter_bands",
    "summary": "Filter the bands by name",
    "description": "Filters the bands in the data cube so that bands that don't match any of the criteria are dropped from the data cube. The data cube is expected to have only one dimension of type `bands`. Fails with a `DimensionMissing` error if no such dimension exists.\n\nThe following criteria can be used to select bands:\n\n* `bands`: band name (e.g. `B01` or `B8A`)\n* `common_names`: common band names (e.g. `red` or `nir`)\n* `wavelengths`: ranges of wavelengths in micrometres (?m) (e.g. 0.5 - 0.6)\n\nTo keep algorithms interoperable it is recommended to prefer the common bands names or the wavelengths over collection and/or back-end specific band names.\n\nIf multiple criteria are specified, any of them must match and not all of them, i.e. they are combined with an OR-operation. If no criteria is specified, the `BandFilterParameterMissing` exception must be thrown.\n\n**Important:** The order of the specified array defines the order of the bands in the data cube, which can be important for subsequent processes. If multiple bands are matched by a single criterion (e.g. a range of wavelengths), they are ordered alphabetically by band names. Bands without names have an arbitrary order.",
    "categories": [
        "filter"
    ],
    "parameter_order": ["data", "bands", "common_names", "wavelengths"],
    "parameters": {
        "data": {
            "description": "A data cube with bands.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "bands": {
            "description": "A list of band names.\n\nThe order of the specified array defines the order of the bands in the data cube.",
            "schema": {
                "type": "array",
                "items": {
                    "type": "string",
                    "format": "band-name"
                }
            }
        },
        "common_names": {
            "description": "A list of common band names.\n\nThe order of the specified array defines the order of the bands in the data cube.",
            "schema": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            }
        },
        "wavelengths": {
            "description": "A list of sub-lists with each sub-list consisting of two elements. The first element is the minimum wavelength and the second element is the maximum wavelength. Wavelengths are specified in micrometres (?m).\n\nThe order of the specified array defines the order of the bands in the data cube.",
            "schema": {
                "type": "array",
                "items": {
                    "type": "array",
                    "minItems": 2,
                    "maxItems": 2,
                    "items": {
                        "type": "number"
                    },
                    "examples": [
                        [[0.45, 0.5], [0.6, 0.7]]
                    ]
                }
            }
        }
    },
    "returns": {
        "description": "A data cube limited to a subset of its original bands. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    },
    "exceptions": {
        "BandFilterParameterMissing": {
            "message": "The process 'filter_bands' requires any of the parameters 'bands', 'common_names' or 'wavelengths' to be set."
        },
        "DimensionMissing": {
            "message": "A band dimension is missing."
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://github.com/radiantearth/stac-spec/tree/master/extensions/eo#common-band-names",
            "title": "List of common band names as specified by the STAC specification"
        }
    ]
    
    },
    {
    "id": "normalized_difference",
    "summary": "Normalized difference for two bands",
    "description": "Computes the normalized difference for two bands. The normalized difference is computed as *(band1 - band2) / (band1 + band2)*.\n\nEach of the parameters expects a raster data cube with exactly one band. The process returns a raster data cube with exactly one band that holds the computed values. The newly created band is named `normalized_difference` by default. This name can be changed with the `name` parameter.\n\nThis process could be used for a number of remote sensing indices such as:\n\n* [NDVI](https://eos.com/ndvi/)\n* [NDWI](https://eos.com/ndwi/)\n* [NDSI](https://eos.com/ndsi/)\n\nPlease note that some back-ends may have native processes available for convenience such as the ``ndvi()``.",
    "categories": [
        "math > indices",
        "vegetation indices"
    ],
    "parameter_order": ["band1", "band2", "name"],
    "parameters": {
        "band1": {
            "description": "A raster data cube with exactly one band to be used as first band.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "band2": {
            "description": "A raster data cube with exactly one band to be used as second band.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "name": {
            "description": "Name of the newly created band with the computed values. Defaults to `normalized_difference`.",
            "schema": {
                "type": "string",
                "default": "normalized_difference",
                "pattern": "^[A-Za-z0-9_]+$"
            }
        }
    },
    "returns": {
        "description": "A raster data cube with exactly one band that holds the computed values.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    },
    "links": [
        {
            "rel": "related",
            "href": "https://eos.com/ndvi/",
            "title": "NDVI explained by EOS"
        },
        {
            "rel": "related",
            "href": "https://eos.com/ndwi/",
            "title": "NDWI explained by EOS"
        },
        {
            "rel": "related",
            "href": "https://eos.com/ndsi/",
            "title": "NDSI explained by EOS"
        }
    ]
    },
    {
		"id": "ndvi",
		"summary": "Normalized Difference Vegetation Index",
		"description": "Computes the Normalized Difference Vegetation Index (NDVI). The NDVI is computed as *(nir - red) / (nir + red)*.\n\nThe `data` parameter expects a raster data cube with two bands that have the common names `red` and `nir` assigned. The process returns a raster data cube with two bands being replaced with a new band that holds the computed values. The newly created band is named `ndvi` by default. This name can be changed with the `name` parameter.\n\nThis process is very similar to the process ``normalized_difference()``, but determines the bands automatically based on the common name (`red`/`nir`) specified in the metadata.",
		"categories": [
			"math > indices",
			"vegetation indices"
		],
		"parameter_order": [
			"data",
			"name"
		],
		"parameters": {
			"data": {
				"description": "A raster data cube with two bands that have the common names `red` and `nir` assigned.",
				"schema": {
					"type": "object",
					"format": "raster-cube"
				},
				"required": true
			},
			"name": {
				"description": "Name of the newly created band with the computed values. Defaults to `normalized_difference`.",
				"schema": {
					"type": "string",
					"default": "normalized_difference",
					"pattern": "^[A-Za-z0-9_]+$"
				}
			}
		},
		"returns": {
			"description": "A raster data cube with the two bands being replaced with a new band that holds the computed values.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		},
		"links": [
			{
				"rel": "about",
				"href": "https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index",
				"title": "NDVI explained by Wikipedia"
			},
			{
				"rel": "about",
				"href": "https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php",
				"title": "NDVI explained by NASA"
			}
		]
	},
	{
    "id": "filter_polygon",
    "summary": "Spatial filter using polygons",
    "description": "Limits the data cube over the spatial dimensions to the specified polygons.\n\nThe filter retains a pixel in the data cube if the point at the pixel center intersects with at least one of the polygons (as defined in the Simple Features standard by the OGC).",
    "categories": [
        "filter"
    ],
    "parameter_order": ["data", "polygons"],
    "parameters": {
        "data": {
            "description": "A data cube.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "polygons": {
            "description": "One or more polygons used for filtering, either specified as GeoJSON or vector data cube.\n\nFor GeoJSON this can be one of the following GeoJSON types:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.",
            "schema": {
                "anyOf": [
                    {
                        "type": "object",
                        "format": "geojson"
                    },
                    {
                        "type": "object",
                        "format": "vector-cube"
                    }
                ]
            },
            "required": true
        }
    },
    "returns": {
        "description": "A data cube restricted to the specified polygons. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    },
    "links": [
        {
            "href": "http://www.opengeospatial.org/standards/sfa",
            "rel": "about",
            "title": "Simple Features standard by the OGC"
        }
    ]
    },
    {
    "id": "mask_colored",
    "summary": "Apply a mask",
    "description": "Applies a mask to a raster data cube. A mask can either be specified as:\n\n* **Raster data cube** for which parallel pixels among `data` and `mask` are compared and those pixels in `data` are replaced, which are non-zero (for numbers) or `true` (for boolean values) in `mask`.\n* **GeoJSON or vector data cube** containing one or more polygons. All pixels for which the point at the pixel center intersects with the corresponding polygon (as defined in the Simple Features standard by the OGC) are replaced.\n\nThe pixel values are replaced with the value specified for `replacement`, which defaults to `null` (no data). No data values will be left untouched by the masking operation.",
    "categories": [
        "masks"
    ],
    "parameter_order": ["data", "lowerThreshold", "upperThreshold", "red", "green", "blue"],
    "parameters": {
        "data": {
            "description": "A raster data cube.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "lowerThreshold": {
            "description": "The threshold used to replace non-zero and `true` values with.",
            "schema": {
                "type": ["string"],
                "default": null
            },
            "required": true
        },
        "upperThreshold": {
            "description": "The threshold used to replace non-zero and `true` values with.",
            "schema": {
                "type": ["string"],
                "default": null
            },
            "required": true
        },
        "red": {
            "description": "The value of color used to replace non-zero and `true` values with.",
            "schema": {
                "type": ["number"],
                "default": null
            },
            "required": true
        },
        "green": {
            "description": "The value of color used to replace non-zero and `true` values with.",
            "schema": {
                "type": ["number"],
                "default": null
            },
            "required": true
        },
        "blue": {
            "description": "The value of color used to replace non-zero and `true` values with.",
            "schema": {
                "type": ["number"],
                "default": null
            },
            "required": true
        }
    },
    "returns": {
        "description": "The masked raster data cube.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    },
    "links": [
        {
            "href": "http://www.opengeospatial.org/standards/sfa",
            "rel": "about",
            "title": "Simple Features standard by the OGC"
    }
    ]
    },
    {
    "id": "resample_spatial",
    "summary": "Resample and warp the spatial dimensions",
    "description": "Resamples the spatial dimensions (x,y) of the data cube to a specified resolution and/or warps the data cube to the target projection. At least `resolution` or `projection` must be specified.\n\nUse ``filter_bbox()`` to set the target spatial extent.",
    "categories": [
        "cubes",
        "aggregate & resample"
    ],
    "parameter_order": ["data", "resolution", "projection", "method", "align"],
    "parameters": {
        "data": {
            "description": "A raster data cube.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "resolution": {
            "description": "Resamples the data cube to the target resolution, which can be specified either as separate values for x and y or as a single value for both axes. Specified in the units of the target projection. Doesn't change the resolution by default (`0`).",
            "schema": {
                "anyOf": [
                    {
                        "description": "A single number used as resolution for both x and y.",
                        "type": "number",
                        "minimum": 0
                    },
                    {
                        "description": "A two-element array to specify separate resolutions for x (first element) and y (second element).",
                        "type": "array",
                        "minItems": 2,
                        "maxItems": 2,
                        "items": {
                            "type": "number",
                            "minimum": 0
                        }
                    }
                ],
                "default": 0
            }
        },
        "projection": {
            "description": "Warps the data cube to the target projection. Target projection specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition. Doesn't change the projection by default (`null`).",
            "schema": {
                "anyOf": [
                    {
                        "title": "EPSG Code",
                        "type": "integer",
                        "format": "epsg-code",
                        "examples": [7099]
                    },
                    {
                        "title": "PROJ definition",
                        "type": "string",
                        "format": "proj-definition",
                        "examples": ["+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"]
                    },
                    {
                        "title": "Don't change projection",
                        "type": "null"
                    }
                ],
                "default": null
            }
        },
        "method": {
          "description": "Resampling method. Methods are inspired by GDAL, see [gdalwarp](https://www.gdal.org/gdalwarp.html) for more information.",
          "schema": {
            "type": "string",
            "default": "near",
            "enum": [
              "near",
              "bilinear",
              "cubic",
              "cubicspline",
              "lanczos",
              "average",
              "mode",
              "max",
              "min",
              "med",
              "q1",
              "q3"
            ]
          }
        },
        "align": {
            "description": "Specifies to which corner of the spatial extent the new resampled data is aligned to.",
            "schema": {
                "type": "string",
                "enum": [
                    "lower-left",
                    "upper-left",
                    "lower-right",
                    "upper-right"
                ],
                "default": "lower-left"
            }
        }
    },
    "returns": {
        "description": "A raster data cube with values warped onto the new projection.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://proj4.org/usage/projections.html",
            "title": "PROJ parameters for cartographic projections"
        },
        {
            "rel": "about",
            "href": "http://www.epsg-registry.org",
            "title": "Official EPSG code registry"
        },
        {
            "rel": "about",
            "href": "http://www.epsg.io",
            "title": "Unofficial EPSG code database"
        }
    ]
    },
    {
		"id": "min_time",
		"summary": "Calculates minimum values of time series.",
		"description": "Finds the minimum value of a time series for every given pixel location for all bands.",
		"parameters": {
			"data": {
				"description": "EO data to process.",
				"required": true,
				"schema": {
					"type": "object",
					"format": "raster-cube"
				}
			}
		},
		"returns": {
			"description": "Processed EO data.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		}
	},
	{
		"id": "max_time",
		"summary": "Calculates maximum values of time series.",
		"description": "Finds the maximum value of a time series for every given pixel location for all bands.",
		"parameters": {
			"data": {
				"description": "EO data to process.",
				"required": true,
				"schema": {
					"type": "object",
					"format": "raster-cube"
				}
			}
		},
		"returns": {
			"description": "Processed EO data.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		}
	},
	{
		"id": "filter_temporal",
		"summary": "Temporal filter for a date and/or time intervals",
		"description": "Limits the data cube to the specified interval of dates and/or times.\n\nMore precisely, the filter checks whether the temporal dimension value is greater than or equal to the lower boundary (start date/time) and the temporal dimension value is less than the value of the upper boundary (end date/time). This corresponds to a left-closed interval, which contains the lower boundary but not the upper boundary.\n\nIf the dimension is set to `null` (it's the default value), the data cube is expected to only have one temporal dimension.",
		"categories": [
			"filter"
		],
		"parameter_order": [
			"data",
			"extent",
			"dimension"
		],
		"parameters": {
			"data": {
				"description": "A data cube.",
				"schema": {
					"type": "object",
					"format": "raster-cube"
				},
				"required": true
			},
			"extent": {
				"description": "Left-closed temporal interval, i.e. an array with exactly two elements:\n\n1. The first element is the start of the date and/or time interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the date and/or time interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.\n\nAlso supports open intervals by setting one of the boundaries to `null`, but never both.",
				"schema": {
					"type": "array",
					"format": "temporal-interval",
					"minItems": 2,
					"maxItems": 2,
					"items": {
						"anyOf": [
							{
								"type": "string",
								"format": "date-time"
							},
							{
								"type": "string",
								"format": "date"
							},
							{
								"type": "string",
								"format": "time"
							},
							{
								"type": "null"
							}
						]
					},
					"examples": [
						[
							"2015-01-01",
							"2016-01-01"
						],
						[
							"12:00:00Z",
							"24:00:00Z"
						]
					]
				},
				"required": true
			},
			"dimension": {
				"description": "The temporal dimension to filter on. If the dimension is not set or is set to `null`, the data cube is expected to only have one temporal dimension. Fails with a `TooManyDimensions` error if it has more dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Note:** The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.",
				"schema": {
					"type": [
						"string",
						"null"
					],
					"default": null
				}
			}
		},
		"returns": {
			"description": "A data cube restricted to the specified temporal extent. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		},
		"exceptions": {
			"DimensionNotAvailable": {
				"message": "A dimension with the specified name does not exist."
			},
			"TooManyDimensions": {
				"message": "The number of temporal dimensions must be reduced to one for 'filter_temporal'."
			}
		},
		"links": [
			{
				"rel": "about",
				"href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
				"title": "Information about the supported temporal formats."
			}
		]
	},
	{
    "id": "filter_bbox",
    "summary": "Spatial filter using a bounding box",
    "description": "Limits the data cube to the specified bounding box.\n\nThe filter retains a pixel in the data cube if the point at the pixel center intersects with the bounding box (as defined in the Simple Features standard by the OGC).",
    "categories": [
        "filter"
    ],
    "parameter_order": ["data", "extent"],
    "parameters": {
        "data": {
            "description": "A data cube.",
            "schema": {
                "type": "object",
                "format": "raster-cube"
            },
            "required": true
        },
        "extent": {
            "description": "A bounding box, which may include a vertical axis (see `base` and `height`).\n\nThe coordinate reference system of the extent must be specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition.",
            "required": true,
            "schema": {
                "type": "object",
                "format": "bounding-box",
                "required": ["west", "south", "east", "north"],
                "properties": {
                    "west": {
                        "description": "West (lower left corner, coordinate axis 1).",
                        "type": "number"
                    },
                    "south": {
                        "description": "South (lower left corner, coordinate axis 2).",
                        "type": "number"
                    },
                    "east": {
                        "description": "East (upper right corner, coordinate axis 1).",
                        "type": "number"
                    },
                    "north": {
                        "description": "North (upper right corner, coordinate axis 2).",
                        "type": "number"
                    },
                    "base": {
                        "description": "Base (optional, lower left corner, coordinate axis 3).",
                        "type": ["number", "null"],
                        "default": null
                    },
                    "height": {
                        "description": "Height (optional, upper right corner, coordinate axis 3).",
                        "type": ["number", "null"],
                        "default": null
                    },
                    "crs": {
                        "description": "Coordinate reference system of the extent specified as EPSG code or PROJ definition. Whenever possible, it is recommended to use EPSG codes instead of PROJ definitions. Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
                        "schema": {
                            "anyOf": [
                                {
                                    "title": "EPSG Code",
                                    "type": "integer",
                                    "format": "epsg-code",
                                    "examples": [7099]
                                },
                                {
                                    "title": "PROJ definition",
                                    "type": "string",
                                    "format": "proj-definition",
                                    "examples": ["+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"]
                                }
                            ],
                            "default": 4326
                        }
                    }
                }
            }
        }
    },
    "returns": {
        "description": "A data cube restricted to the bounding box. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
        "schema": {
            "type": "object",
            "format": "raster-cube"
        }
    },
    "links": [
        {
            "rel": "about",
            "href": "https://proj4.org/usage/projections.html",
            "title": "PROJ parameters for cartographic projections"
        },
        {
            "rel": "about",
            "href": "http://www.epsg-registry.org",
            "title": "Official EPSG code registry"
        },
        {
            "rel": "about",
            "href": "http://www.epsg.io",
            "title": "Unofficial EPSG code database"
        },
        {
            "href": "http://www.opengeospatial.org/standards/sfa",
            "rel": "about",
            "title": "Simple Features standard by the OGC"
        }
    ]
    },
    {
		"id": "load_collection",
		"summary": "Load a collection",
		"description": "Loads a collection from the current back-end by its id and returns it as processable data cube. The data that is added to the data cube can be restricted with the additional `spatial_extent`, `temporal_extent`, `bands` and `properties`.\n\n**Remarks:**\n\n* The bands (and all dimensions that specify nominal dimension values) are expected to be ordered as specified in the metadata if the `bands` parameter is set to `null`.\n* If no additional parameter is specified this would imply that the whole data set is expected to be loaded. Due to the large size of many data sets this is not recommended and may be optimized by back-ends to only load the data that is actually required after evaluating subsequent processes such as filters. This means that the pixel values should be processed only after the data has been limited to the required extents and as a consequence also to a manageable size.",
		"categories": [
			"cubes",
			"import"
		],
		"parameter_order": [
			"id",
			"spatial_extent",
			"temporal_extent",
			"bands",
			"properties"
		],
		"parameters": {
			"id": {
				"description": "The collection id.",
				"schema": {
					"type": "string",
					"format": "collection-id",
					"pattern": "^[A-Za-z0-9_\\-\\.~\/]+$"
				},
				"required": true
			},
			"spatial_extent": {
				"description": "Limits the data to load from the collection to the specified bounding box or polygons.\n\nThe process puts a pixel into the data cube if the point at the pixel center intersects with the bounding box or any of the polygons (as defined in the Simple Features standard by the OGC).\n\nThe coordinate reference system of the bounding box must be specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition.\n\nThe GeoJSON can be one of the following GeoJSON types:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
				"schema": {
					"anyOf": [
						{
							"title": "Bounding Box",
							"type": "object",
							"format": "bounding-box",
							"required": [
								"west",
								"south",
								"east",
								"north"
							],
							"properties": {
								"west": {
									"description": "West (lower left corner, coordinate axis 1).",
									"type": "number"
								},
								"south": {
									"description": "South (lower left corner, coordinate axis 2).",
									"type": "number"
								},
								"east": {
									"description": "East (upper right corner, coordinate axis 1).",
									"type": "number"
								},
								"north": {
									"description": "North (upper right corner, coordinate axis 2).",
									"type": "number"
								},
								"base": {
									"description": "Base (optional, lower left corner, coordinate axis 3).",
									"type": [
										"number",
										"null"
									],
									"default": null
								},
								"height": {
									"description": "Height (optional, upper right corner, coordinate axis 3).",
									"type": [
										"number",
										"null"
									],
									"default": null
								},
								"crs": {
									"description": "Coordinate reference system of the extent specified as EPSG code or PROJ definition. Whenever possible, it is recommended to use EPSG codes instead of PROJ definitions. Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
									"schema": {
										"anyOf": [
											{
												"title": "EPSG Code",
												"type": "integer",
												"format": "epsg-code",
												"examples": [
													7099
												]
											},
											{
												"title": "PROJ definition",
												"type": "string",
												"format": "proj-definition",
												"examples": [
													"+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
												]
											}
										],
										"default": 4326
									}
								}
							}
						},
						{
							"title": "GeoJSON Polygon(s)",
							"type": "object",
							"format": "geojson"
						},
						{
							"type": "null"
						}
					]
				},
				"required": true
			},
			"temporal_extent": {
				"description": "Limits the data to load from the collection to the specified left-closed temporal interval. Applies to all temporal dimensions if there are multiple of them. The interval has to be specified as an array with exactly two elements:\n\n1. The first element is the start of the date and/or time interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the date and/or time interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.\n\nAlso supports open intervals by setting one of the boundaries to `null`, but never both.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
				"schema": {
					"anyOf": [
						{
							"type": "array",
							"format": "temporal-interval",
							"minItems": 2,
							"maxItems": 2,
							"items": {
								"anyOf": [
									{
										"type": "string",
										"format": "date-time"
									},
									{
										"type": "string",
										"format": "date"
									},
									{
										"type": "string",
										"format": "time"
									},
									{
										"type": "null"
									}
								]
							},
							"examples": [
								[
									"2015-01-01",
									"2016-01-01"
								],
								[
									"12:00:00Z",
									"24:00:00Z"
								]
							]
						},
						{
							"type": "null"
						}
					]
				},
				"required": true
			},
			"bands": {
				"description": "Only adds the specified bands into the data cube so that bands that don't match the list of band names are not available. Applies to all dimensions of type `bands` if there are multiple of them.\n\nThe order of the specified array defines the order of the bands in the data cube.",
				"schema": {
					"anyOf": [
						{
							"type": "array",
							"items": {
								"type": "string",
								"format": "band-name"
							}
						},
						{
							"type": "null"
						}
					],
					"default": "null"
				}
			},
			"properties": {
				"description": "Limits the data by metadata properties to include only data in the data cube which all given expressions return `true` for (AND operation).\n\nSpecify key-value-pairs with the keys being the name of the metadata property, which can be retrieved with the openEO Data Discovery for Collections. The values must be expressions to be evaluated against the collection metadata, see the example.\n\n**Note:** Back-ends may not pass the actual value to the expressions, but pass a proprietary index or a placeholder so that they can use the expressions to query against another data source. So debugging on the callback parameter `value` may lead to unexpected results.",
				"experimental": true,
				"schema": {
					"anyOf": [
						{
							"type": "object",
							"additionalProperties": {
								"type": "object",
								"format": "callback",
								"parameters": {
									"value": {
										"description": "The property value. Any data type could be passed."
									}
								}
							}
						},
						{
							"type": "null"
						}
					],
					"default": null
				}
			}
		},
		"returns": {
			"description": "A data cube for further processing.",
			"schema": {
				"anyOf": [
					{
						"type": "object",
						"format": "raster-cube"
					},
					{
						"type": "object",
						"format": "vector-cube"
					}
				]
			}
		},
		"links": [
			{
				"rel": "about",
				"href": "https://proj4.org/usage/projections.html",
				"title": "PROJ parameters for cartographic projections"
			},
			{
				"rel": "about",
				"href": "http://www.epsg-registry.org",
				"title": "Official EPSG code registry"
			},
			{
				"rel": "about",
				"href": "http://www.epsg.io",
				"title": "Unofficial EPSG code database"
			},
			{
				"href": "http://www.opengeospatial.org/standards/sfa",
				"rel": "about",
				"title": "Simple Features standard by the OGC"
			},
			{
				"rel": "about",
				"href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
				"title": "Information about the supported temporal formats."
			}
		]
	}
] 
