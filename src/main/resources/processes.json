[
	{
		"id": "apply",
		"summary": "Applies a unary process to each pixel",
		"description": "Applies a **unary** process which takes a single value such as `abs` or `sqrt` to each pixel value in the data cube (i.e. a local operation). In contrast, the process ``apply_dimension()`` applies an n-ary process to a particular dimension.",
		"categories": [
			"cubes"
		],
		"parameter_order": [
			"data",
			"process"
		],
		"parameters": {
			"data": {
				"description": "A data cube.",
				"schema": {
					"type": "object",
					"format": "raster-cube"
				},
				"required": true
			},
			"process": {
				"description": "A process (callback) to be applied on each value. The specified process must be unary meaning that it must work on a single value.",
				"schema": {
					"type": "object",
					"format": "callback",
					"parameters": {
						"x": {
							"description": "A value of any type could be passed."
						}
					}
				},
				"required": true
			}
		},
		"returns": {
			"description": "A data cube with the newly computed values. The resolution, cardinality and the number of dimensions are the same as for the original data cube.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		}
	},
	{
		"id": "linear_scale_range",
		"summary": "Linear transformation between two ranges",
		"description": "Performs a linear transformation between the input and output range.\n\nThe underlying formula is: `((x - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin`.\n\nPotential use case include\n\n* scaling values to the 8-bit range (0 - 255) often used for numeric representation of values in one of the channels of the [RGB colour model](https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations) or\n* calculating percentages (0 - 100).\n\nThe no-data value `null` is passed through and therefore gets propagated.",
		"categories": [
			"math"
		],
		"parameter_order": [
			"x",
			"inputMin",
			"inputMax",
			"outputMin",
			"outputMax"
		],
		"parameters": {
			"x": {
				"description": "A number to transform.",
				"schema": {
					"type": [
						"number",
						"null"
					]
				},
				"required": true
			},
			"inputMin": {
				"description": "Minimum value the input can obtain.",
				"schema": {
					"type": "number"
				},
				"required": true
			},
			"inputMax": {
				"description": "Maximum value the input can obtain.",
				"schema": {
					"type": "number"
				},
				"required": true
			},
			"outputMin": {
				"description": "Minimum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 0
				}
			},
			"outputMax": {
				"description": "Maximum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 1
				}
			}
		},
		"returns": {
			"description": "The transformed number.",
			"schema": {
				"type": [
					"number",
					"null"
				]
			}
		}
	},
	{
		"id": "linear_scale_cube",
		"summary": "Linear transformation between two ranges",
		"description": "Performs a linear transformation between the input and output range.\n\nThe underlying formula is: `((x - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin`.\n\nPotential use case include\n\n* scaling values to the 8-bit range (0 - 255) often used for numeric representation of values in one of the channels of the [RGB colour model](https://en.wikipedia.org/wiki/RGB_color_model#Numeric_representations) or\n* calculating percentages (0 - 100).\n\nThe no-data value `null` is passed through and therefore gets propagated.",
		"categories": [
			"math"
		],
		"parameter_order": [
			"data",
			"inputMin",
			"inputMax",
			"outputMin",
			"outputMax"
		],
		"parameters": {
			"data": {
				"description": "A raster data cube",
				"schema": {
					"type": "object",
					"format": "raster-cube"
				},
				"required": true
			},
			"inputMin": {
				"description": "Minimum value the input can obtain.",
				"schema": {
					"type": "number"
				},
				"required": true
			},
			"inputMax": {
				"description": "Maximum value the input can obtain.",
				"schema": {
					"type": "number"
				},
				"required": true
			},
			"outputMin": {
				"description": "Minimum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 0
				}
			},
			"outputMax": {
				"description": "Maximum value of the desired output range.",
				"schema": {
					"type": "number",
					"default": 1
				}
			}
		},
		"returns": {
			"description": "A raster data cube with every value in the cube scaled according to the min and max parameters.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		}
	},
	{
		"id": "save_result",
		"summary": "Save processed data to storage",
		"description": "Saves processed data to the local user workspace / data store of the authenticated user. This process aims to be compatible to GDAL/OGR formats and options. STAC-compatible metadata should be stored with the processed data.\n\nCalling this process may be rejected by back-ends in the context of secondary web services.",
		"categories": [
			"cubes",
			"export"
		],
		"parameter_order": [
			"data",
			"format",
			"options"
		],
		"parameters": {
			"data": {
				"description": "The data to save.",
				"schema": {
					"anyOf": [
						{
							"type": "object",
							"format": "raster-cube"
						},
						{
							"type": "object",
							"format": "vector-cube"
						}
					]
				},
				"required": true
			},
			"format": {
				"description": "The file format to save to. It must be one of the values that the server reports as supported output formats, which usually correspond to the short GDAL/OGR codes. This parameter is *case insensitive*.",
				"schema": {
					"type": "string",
					"format": "output-format"
				},
				"required": true
			},
			"options": {
				"description": "The file format options to be used to create the file(s). Must correspond to the options that the server reports as supported options for the chosen `format`. The option names and valid values usually correspond to the GDAL/OGR format options.",
				"schema": {
					"type": "object",
					"format": "output-format-options",
					"default": {
						
					}
				}
			}
		},
		"returns": {
			"description": "`false` if saving failed, `true` otherwise.",
			"schema": {
				"type": "boolean"
			}
		},
		"links": [
			{
				"rel": "about",
				"href": "https://www.gdal.org/formats_list.html",
				"title": "GDAL Raster Formats"
			},
			{
				"rel": "about",
				"href": "https://www.gdal.org/ogr_formats.html",
				"title": "OGR Vector Formats"
			}
		]
	},
	{
		"id": "ndvi",
		"summary": "Normalized Difference Vegetation Index",
		"description": "Computes the Normalized Difference Vegetation Index (NDVI). The NDVI is computed as *(nir - red) / (nir + red)*.\n\nThe `data` parameter expects a raster data cube with two bands that have the common names `red` and `nir` assigned. The process returns a raster data cube with two bands being replaced with a new band that holds the computed values. The newly created band is named `ndvi` by default. This name can be changed with the `name` parameter.\n\nThis process is very similar to the process ``normalized_difference()``, but determines the bands automatically based on the common name (`red`/`nir`) specified in the metadata.",
		"categories": [
			"math > indices",
			"vegetation indices"
		],
		"parameter_order": [
			"data",
			"name"
		],
		"parameters": {
			"data": {
				"description": "A raster data cube with two bands that have the common names `red` and `nir` assigned.",
				"schema": {
					"type": "object",
					"format": "raster-cube"
				},
				"required": true
			},
			"name": {
				"description": "Name of the newly created band with the computed values. Defaults to `normalized_difference`.",
				"schema": {
					"type": "string",
					"default": "normalized_difference",
					"pattern": "^[A-Za-z0-9_]+$"
				}
			}
		},
		"returns": {
			"description": "A raster data cube with the two bands being replaced with a new band that holds the computed values.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		},
		"links": [
			{
				"rel": "about",
				"href": "https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index",
				"title": "NDVI explained by Wikipedia"
			},
			{
				"rel": "about",
				"href": "https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php",
				"title": "NDVI explained by NASA"
			}
		]
	},
	{
		"id": "min_time",
		"summary": "Calculates minimum values of time series.",
		"description": "Finds the minimum value of a time series for every given pixel location for all bands.",
		"parameters": {
			"data": {
				"description": "EO data to process.",
				"required": true,
				"schema": {
					"type": "object",
					"format": "raster-cube"
				}
			}
		},
		"returns": {
			"description": "Processed EO data.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		}
	},
	{
		"id": "max_time",
		"summary": "Calculates maximum values of time series.",
		"description": "Finds the maximum value of a time series for every given pixel location for all bands.",
		"parameters": {
			"data": {
				"description": "EO data to process.",
				"required": true,
				"schema": {
					"type": "object",
					"format": "raster-cube"
				}
			}
		},
		"returns": {
			"description": "Processed EO data.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		}
	},
	{
		"id": "filter_temporal",
		"summary": "Temporal filter for a date and/or time intervals",
		"description": "Limits the data cube to the specified interval of dates and/or times.\n\nMore precisely, the filter checks whether the temporal dimension value is greater than or equal to the lower boundary (start date/time) and the temporal dimension value is less than the value of the upper boundary (end date/time). This corresponds to a left-closed interval, which contains the lower boundary but not the upper boundary.\n\nIf the dimension is set to `null` (it's the default value), the data cube is expected to only have one temporal dimension.",
		"categories": [
			"filter"
		],
		"parameter_order": [
			"data",
			"extent",
			"dimension"
		],
		"parameters": {
			"data": {
				"description": "A data cube.",
				"schema": {
					"type": "object",
					"format": "raster-cube"
				},
				"required": true
			},
			"extent": {
				"description": "Left-closed temporal interval, i.e. an array with exactly two elements:\n\n1. The first element is the start of the date and/or time interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the date and/or time interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.\n\nAlso supports open intervals by setting one of the boundaries to `null`, but never both.",
				"schema": {
					"type": "array",
					"format": "temporal-interval",
					"minItems": 2,
					"maxItems": 2,
					"items": {
						"anyOf": [
							{
								"type": "string",
								"format": "date-time"
							},
							{
								"type": "string",
								"format": "date"
							},
							{
								"type": "string",
								"format": "time"
							},
							{
								"type": "null"
							}
						]
					},
					"examples": [
						[
							"2015-01-01",
							"2016-01-01"
						],
						[
							"12:00:00Z",
							"24:00:00Z"
						]
					]
				},
				"required": true
			},
			"dimension": {
				"description": "The temporal dimension to filter on. If the dimension is not set or is set to `null`, the data cube is expected to only have one temporal dimension. Fails with a `TooManyDimensions` error if it has more dimensions. Fails with a `DimensionNotAvailable` error if the specified dimension does not exist.\n\n**Note:** The default dimensions a data cube provides are described in the collection's metadata field `cube:dimensions`.",
				"schema": {
					"type": [
						"string",
						"null"
					],
					"default": null
				}
			}
		},
		"returns": {
			"description": "A data cube restricted to the specified temporal extent. Therefore, the cardinality is potentially lower, but the resolution and the number of dimensions are the same as for the original data cube.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		},
		"exceptions": {
			"DimensionNotAvailable": {
				"message": "A dimension with the specified name does not exist."
			},
			"TooManyDimensions": {
				"message": "The number of temporal dimensions must be reduced to one for 'filter_temporal'."
			}
		},
		"links": [
			{
				"rel": "about",
				"href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
				"title": "Information about the supported temporal formats."
			}
		]
	},
	{
		"id": "load_collection",
		"summary": "Load a collection",
		"description": "Loads a collection from the current back-end by its id and returns it as processable data cube. The data that is added to the data cube can be restricted with the additional `spatial_extent`, `temporal_extent`, `bands` and `properties`.\n\n**Remarks:**\n\n* The bands (and all dimensions that specify nominal dimension values) are expected to be ordered as specified in the metadata if the `bands` parameter is set to `null`.\n* If no additional parameter is specified this would imply that the whole data set is expected to be loaded. Due to the large size of many data sets this is not recommended and may be optimized by back-ends to only load the data that is actually required after evaluating subsequent processes such as filters. This means that the pixel values should be processed only after the data has been limited to the required extents and as a consequence also to a manageable size.",
		"categories": [
			"cubes",
			"import"
		],
		"parameter_order": [
			"id",
			"spatial_extent",
			"temporal_extent",
			"bands",
			"properties"
		],
		"parameters": {
			"id": {
				"description": "The collection id.",
				"schema": {
					"type": "string",
					"format": "collection-id",
					"pattern": "^[A-Za-z0-9_\\-\\.~\/]+$"
				},
				"required": true
			},
			"spatial_extent": {
				"description": "Limits the data to load from the collection to the specified bounding box or polygons.\n\nThe process puts a pixel into the data cube if the point at the pixel center intersects with the bounding box or any of the polygons (as defined in the Simple Features standard by the OGC).\n\nThe coordinate reference system of the bounding box must be specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition.\n\nThe GeoJSON can be one of the following GeoJSON types:\n\n* A `Polygon` geometry,\n* a `GeometryCollection` containing Polygons,\n* a `Feature` with a `Polygon` geometry or\n* a `FeatureCollection` containing `Feature`s with a `Polygon` geometry.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
				"schema": {
					"anyOf": [
						{
							"title": "Bounding Box",
							"type": "object",
							"format": "bounding-box",
							"required": [
								"west",
								"south",
								"east",
								"north"
							],
							"properties": {
								"west": {
									"description": "West (lower left corner, coordinate axis 1).",
									"type": "number"
								},
								"south": {
									"description": "South (lower left corner, coordinate axis 2).",
									"type": "number"
								},
								"east": {
									"description": "East (upper right corner, coordinate axis 1).",
									"type": "number"
								},
								"north": {
									"description": "North (upper right corner, coordinate axis 2).",
									"type": "number"
								},
								"base": {
									"description": "Base (optional, lower left corner, coordinate axis 3).",
									"type": [
										"number",
										"null"
									],
									"default": null
								},
								"height": {
									"description": "Height (optional, upper right corner, coordinate axis 3).",
									"type": [
										"number",
										"null"
									],
									"default": null
								},
								"crs": {
									"description": "Coordinate reference system of the extent specified as EPSG code or PROJ definition. Whenever possible, it is recommended to use EPSG codes instead of PROJ definitions. Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
									"schema": {
										"anyOf": [
											{
												"title": "EPSG Code",
												"type": "integer",
												"format": "epsg-code",
												"examples": [
													7099
												]
											},
											{
												"title": "PROJ definition",
												"type": "string",
												"format": "proj-definition",
												"examples": [
													"+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
												]
											}
										],
										"default": 4326
									}
								}
							}
						},
						{
							"title": "GeoJSON Polygon(s)",
							"type": "object",
							"format": "geojson"
						},
						{
							"type": "null"
						}
					]
				},
				"required": true
			},
			"temporal_extent": {
				"description": "Limits the data to load from the collection to the specified left-closed temporal interval. Applies to all temporal dimensions if there are multiple of them. The interval has to be specified as an array with exactly two elements:\n\n1. The first element is the start of the date and/or time interval. The specified instance in time is **included** in the interval.\n2. The second element is the end of the date and/or time interval. The specified instance in time is **excluded** from the interval.\n\nThe specified temporal strings follow [RFC 3339](https://tools.ietf.org/html/rfc3339). Although [RFC 3339 prohibits the hour to be '24'](https://tools.ietf.org/html/rfc3339#section-5.7), **this process allows the value '24' for the hour** of an end time in order to make it possible that left-closed time intervals can fully cover the day.\n\nAlso supports open intervals by setting one of the boundaries to `null`, but never both.\n\nSet this parameter to `null` to set no limit for the spatial extent. Be careful with this when loading large datasets!",
				"schema": {
					"anyOf": [
						{
							"type": "array",
							"format": "temporal-interval",
							"minItems": 2,
							"maxItems": 2,
							"items": {
								"anyOf": [
									{
										"type": "string",
										"format": "date-time"
									},
									{
										"type": "string",
										"format": "date"
									},
									{
										"type": "string",
										"format": "time"
									},
									{
										"type": "null"
									}
								]
							},
							"examples": [
								[
									"2015-01-01",
									"2016-01-01"
								],
								[
									"12:00:00Z",
									"24:00:00Z"
								]
							]
						},
						{
							"type": "null"
						}
					]
				},
				"required": true
			},
			"bands": {
				"description": "Only adds the specified bands into the data cube so that bands that don't match the list of band names are not available. Applies to all dimensions of type `bands` if there are multiple of them.\n\nThe order of the specified array defines the order of the bands in the data cube.",
				"schema": {
					"anyOf": [
						{
							"type": "array",
							"items": {
								"type": "string",
								"format": "band-name"
							}
						},
						{
							"type": "null"
						}
					],
					"default": "null"
				}
			},
			"properties": {
				"description": "Limits the data by metadata properties to include only data in the data cube which all given expressions return `true` for (AND operation).\n\nSpecify key-value-pairs with the keys being the name of the metadata property, which can be retrieved with the openEO Data Discovery for Collections. The values must be expressions to be evaluated against the collection metadata, see the example.\n\n**Note:** Back-ends may not pass the actual value to the expressions, but pass a proprietary index or a placeholder so that they can use the expressions to query against another data source. So debugging on the callback parameter `value` may lead to unexpected results.",
				"experimental": true,
				"schema": {
					"anyOf": [
						{
							"type": "object",
							"additionalProperties": {
								"type": "object",
								"format": "callback",
								"parameters": {
									"value": {
										"description": "The property value. Any data type could be passed."
									}
								}
							}
						},
						{
							"type": "null"
						}
					],
					"default": null
				}
			}
		},
		"returns": {
			"description": "A data cube for further processing.",
			"schema": {
				"anyOf": [
					{
						"type": "object",
						"format": "raster-cube"
					},
					{
						"type": "object",
						"format": "vector-cube"
					}
				]
			}
		},
		"links": [
			{
				"rel": "about",
				"href": "https://proj4.org/usage/projections.html",
				"title": "PROJ parameters for cartographic projections"
			},
			{
				"rel": "about",
				"href": "http://www.epsg-registry.org",
				"title": "Official EPSG code registry"
			},
			{
				"rel": "about",
				"href": "http://www.epsg.io",
				"title": "Unofficial EPSG code database"
			},
			{
				"href": "http://www.opengeospatial.org/standards/sfa",
				"rel": "about",
				"title": "Simple Features standard by the OGC"
			},
			{
				"rel": "about",
				"href": "https://open-eo.github.io/openeo-api/processes/#openeo-specific-formats",
				"title": "Information about the supported temporal formats."
			}
		]
	},
	{
		"id": "resample_spatial",
		"summary": "Resample and warp the spatial dimensions",
		"description": "Resamples the spatial dimensions (x,y) of the data cube to a specified resolution and/or warps the data cube to the target projection. At least `resolution` or `projection` must be specified.\n\nUse ``filter_bbox()`` to set the target spatial extent.",
		"categories": [
			"cubes",
			"aggregate & resample"
		],
		"parameter_order": [
			"data",
			"resolution",
			"projection",
			"method",
			"align"
		],
		"parameters": {
			"data": {
				"description": "A raster data cube.",
				"schema": {
					"type": "object",
					"format": "raster-cube"
				},
				"required": true
			},
			"resolution": {
				"description": "Resamples the data cube to the target resolution, which can be specified either as separate values for x and y or as a single value for both axes. Specified in the units of the target projection. Doesn't change the resolution by default (`0`).",
				"schema": {
					"anyOf": [
						{
							"description": "A single number used as resolution for both x and y.",
							"type": "number",
							"minimum": 0
						},
						{
							"description": "A two-element array to specify separate resolutions for x (first element) and y (second element).",
							"type": "array",
							"minItems": 2,
							"maxItems": 2,
							"items": {
								"type": "number",
								"minimum": 0
							}
						}
					],
					"default": 0
				}
			},
			"projection": {
				"description": "Warps the data cube to the target projection. Target projection specified as [EPSG](http://www.epsg.org) code or [PROJ](https://proj4.org) definition. Doesn't change the projection by default (`null`).",
				"schema": {
					"anyOf": [
						{
							"title": "EPSG Code",
							"type": "integer",
							"format": "epsg-code",
							"examples": [
								7099
							]
						},
						{
							"title": "PROJ definition",
							"type": "string",
							"format": "proj-definition",
							"examples": [
								"+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
							]
						},
						{
							"title": "Don't change projection",
							"type": "null"
						}
					],
					"default": null
				}
			},
			"method": {
				"description": "Resampling method. Methods are inspired by GDAL, see [gdalwarp](https://www.gdal.org/gdalwarp.html) for more information.",
				"schema": {
					"type": "string",
					"default": "near",
					"enum": [
						"near",
						"bilinear",
						"cubic",
						"cubicspline",
						"lanczos",
						"average",
						"mode",
						"max",
						"min",
						"med",
						"q1",
						"q3"
					]
				}
			},
			"align": {
				"description": "Specifies to which corner of the spatial extent the new resampled data is aligned to.",
				"schema": {
					"type": "string",
					"enum": [
						"lower-left",
						"upper-left",
						"lower-right",
						"upper-right"
					],
					"default": "lower-left"
				}
			}
		},
		"returns": {
			"description": "A raster data cube with values warped onto the new projection.",
			"schema": {
				"type": "object",
				"format": "raster-cube"
			}
		},
		"links": [
			{
				"rel": "about",
				"href": "https://proj4.org/usage/projections.html",
				"title": "PROJ parameters for cartographic projections"
			},
			{
				"rel": "about",
				"href": "http://www.epsg-registry.org",
				"title": "Official EPSG code registry"
			},
			{
				"rel": "about",
				"href": "http://www.epsg.io",
				"title": "Unofficial EPSG code database"
			}
		]
	}
] 
